<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="本系列文章记录笔者刷LeetCode的一些总结，本文为动态规划篇。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode总结——动态规划篇">
<meta property="og:url" content="https://yoursite.com/2024/04/08/Leetcode%E6%80%BB%E7%BB%93-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87/index.html">
<meta property="og:site_name" content="杜遇随笔">
<meta property="og:description" content="本系列文章记录笔者刷LeetCode的一些总结，本文为动态规划篇。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-07T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-16T02:56:53.686Z">
<meta property="article:author" content="linpandas">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://yoursite.com/2024/04/08/Leetcode%E6%80%BB%E7%BB%93-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yoursite.com/2024/04/08/Leetcode%E6%80%BB%E7%BB%93-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87/","path":"2024/04/08/Leetcode总结-动态规划篇/","title":"LeetCode总结——动态规划篇"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LeetCode总结——动态规划篇 | 杜遇随笔</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">杜遇随笔</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">1.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97"><span class="nav-number">1.1.</span> <span class="nav-text">背包问题系列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-1%E8%83%8C%E5%8C%85"><span class="nav-number">1.1.1.</span> <span class="nav-text">0-1背包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0-1%E8%83%8C%E5%8C%85%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8%EF%BC%9A"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">0-1背包经典应用：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="nav-number">1.1.2.</span> <span class="nav-text">完全背包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.3.</span> <span class="nav-text">完全背包题型总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97"><span class="nav-number">1.2.</span> <span class="nav-text">打家劫舍系列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text">股票系列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97"><span class="nav-number">1.4.</span> <span class="nav-text">子序列系列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.4.1.</span> <span class="nav-text">不连续子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.4.2.</span> <span class="nav-text">连续子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">1.4.3.</span> <span class="nav-text">编辑距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%96%87"><span class="nav-number">1.4.4.</span> <span class="nav-text">回文</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="linpandas"
      src="/images/portrait.gif">
  <p class="site-author-name" itemprop="name">linpandas</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/linpandas" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;linpandas" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:juguodu@163.com" title="E-Mail → mailto:juguodu@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2024/04/08/Leetcode%E6%80%BB%E7%BB%93-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/portrait.gif">
      <meta itemprop="name" content="linpandas">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜遇随笔">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode总结——动态规划篇
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-08 00:00:00" itemprop="dateCreated datePublished" datetime="2024-04-08T00:00:00+08:00">2024-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-16 10:56:53" itemprop="dateModified" datetime="2024-04-16T10:56:53+08:00">2024-04-16</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本系列文章记录笔者刷LeetCode的一些总结，本文为动态规划篇。</p>
<span id="more"></span>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/description/">509. 斐波那契数</a></p>
<p>用递归和动态规划都可以。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/description/">70. 爬楼梯</a></p>
<p>爬楼梯问题的dp数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp = [0] * (n+1)</span><br></pre></td></tr></table></figure>
<p>递推公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i-1] + dp[i-2]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/">746. 使用最小花费爬楼梯</a></p>
<p>dp[i]：爬到第i个台阶的最小费用</p>
<p>初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[0], dp[1] = 0, 0</span><br></pre></td></tr></table></figure>
<p>递推公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = min(cost[i-2]+dp[i-2], cost[i-1]+dp[i-1])</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/description/">62. 不同路径</a></p>
<p>二维dp，不同路径问题的dp:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp = [[0]*n for _ in range(m)]</span><br></pre></td></tr></table></figure>
<p>将第一行第一列初始化为1，其余位置初始化为0后，从(1,1)开始遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1,m):</span><br><span class="line">    for j in range(1,n):</span><br><span class="line">        dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/description/">63. 不同路径 II</a></p>
<p>将第一行第一列初始化为1（若遇到障碍，则障碍后的全初始化为0），其余位置初始化为0后，从(1,1)开始遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1, m):</span><br><span class="line">    for j in range(1, n):</span><br><span class="line">        if obstacleGrid[i][j] == 1:</span><br><span class="line">            continue</span><br><span class="line">        dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/description/">343. 整数拆分</a></p>
<p>背！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def integerBreak(self, n: int) -&gt; int:</span><br><span class="line">        # 动态规划</span><br><span class="line">        dp = [0] * (n + 1) # 拆分数字i，可以得到的最大乘积为dp[i]</span><br><span class="line">        dp[2] = 1</span><br><span class="line">        for i in range(3, n + 1):</span><br><span class="line">            for j in range(1, n):</span><br><span class="line">                dp[i] = max(dp[i], j*(i-j), dp[j]*(i-j))</span><br><span class="line"></span><br><span class="line">        return dp[n]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/description/">96. 不同的二叉搜索树</a></p>
<p>dp[i]: i个不同节点组成的二叉搜索树的个数</p>
<p>以n=3为例：</p>
<ul>
<li>元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</li>
<li>元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</li>
<li>元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</li>
</ul>
<p>且：</p>
<ul>
<li>有2个元素的搜索树数量就是dp[2]。</li>
<li>有1个元素的搜索树数量就是dp[1]。</li>
<li>有0个元素的搜索树数量就是dp[0]。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numTrees(self, n: int) -&gt; int:</span><br><span class="line">        dp = [0] * (n+1) # 1到i为节点组成的二叉搜索树的个数</span><br><span class="line">        dp[0] = 1</span><br><span class="line">        for i in range(1, n+1):</span><br><span class="line">            for j in range(1, i+1):</span><br><span class="line">                dp[i] += dp[j-1] * dp[i-j]</span><br><span class="line">        </span><br><span class="line">        return dp[n]</span><br></pre></td></tr></table></figure>
<h2 id="背包问题系列"><a href="#背包问题系列" class="headerlink" title="背包问题系列"></a>背包问题系列</h2><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><p>问题描述：有n件物品和一个最多能背重量为w的背包，第i件物品的重量是weight[i]，得到的价值为value[i]，<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品的价值总和最大。</p>
<p>dp[i][j]：从下标为[0-i]的物品里任取，放进容量为j的背包，价值总和最大为多少。</p>
<p>初始化：<strong>0-1背包的初始化都需要在背包容量的基础上+1</strong>！如<code>dp = [0] * (bagWeight+1)</code></p>
<p>递推公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br></pre></td></tr></table></figure>
<p>使用一维dp数组时，为了防止物品被多次使用，遍历背包时需要从后往前遍历。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def zero_one_bag(weight, value, bagWeight):</span><br><span class="line">    dp = [0] * (bagWeight+1)</span><br><span class="line">    for i in range(len(weight)):</span><br><span class="line">        for j in range(bagWeight, weight[i]-1, -1):</span><br><span class="line">            dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">    </span><br><span class="line">    return dp[bagWeight]</span><br></pre></td></tr></table></figure>
<h4 id="0-1背包经典应用："><a href="#0-1背包经典应用：" class="headerlink" title="0-1背包经典应用："></a>0-1背包经典应用：</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">416. 分割等和子集</a></p>
<p>将一个数组分割为和相等的两个数组，等价于从该数组中挑选出能装满容量为该数组和的一半的物品，从而转换为0-1背包问题。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/description/">1049. 最后一块石头的重量 II</a></p>
<p>算出石头总重量，模2得到背包容量，背包能装包的最大重量就是较小那堆石头的重量，从而转换为0-1背包问题。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/description/">494. 目标和</a></p>
<p>x为加法总和，sum-x为减法总和，故x-(sum-x)=target，可推出x = (sum+target)/2。</p>
<p>本题与0-1背包稍有不同，主要体现在：</p>
<ul>
<li>dp[j]表示填满容量为j（包括j）的背包有dp[j]种方法。</li>
<li>本题为组合问题，递推公式为<code>dp[j] += dp[j-nums[i]]</code>。</li>
<li>由递推公式可以看出，dp[0]需要初始化为1。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/description/">474. 一和零</a></p>
<p>本题可看作有两个维度的0-1背包：装0的维度和装1的维度。</p>
<p>dp[i][j]表示最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。</p>
<p>循环体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for s in strs:</span><br><span class="line">    zeros = s.count(&quot;0&quot;)</span><br><span class="line">    ones = s.count(&quot;1&quot;)</span><br><span class="line">    for i in range(m, zeros-1, -1):</span><br><span class="line">        for j in range(n, ones-1, -1):</span><br><span class="line">            dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)</span><br></pre></td></tr></table></figure>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>问题描述：有n件物品和一个最多能背重量为w的背包，第i件物品的重量是weight[i]，得到的价值为value[i]，<strong>每件物品都有无限个</strong>，求解将哪些物品装入背包里物品的价值总和最大。</p>
<p>dp[i][j]：从下标为[0-i]的物品里任取，放进容量为j的背包，价值总和最大为多少。</p>
<p>在0-1背包中，为了防止物品被多次使用，遍历背包时需要从后往前遍历。但在完全背包中，因为物品可以多次使用，故遍历背包需要<strong>从前向后</strong>！</p>
<p>初始化：<strong>完全背包的初始化都需要在背包容量的基础上+1</strong>！如<code>dp = [0] * (bagWeight+1)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def complete_bag(weight, value, bagWeight):</span><br><span class="line">    dp = [0] * (bagWeight+1)</span><br><span class="line">    for i in range(len(weight)):</span><br><span class="line">        for j in range(weight[i], bagWeight+1):</span><br><span class="line">            dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line"></span><br><span class="line">    return dp[bagWeight]</span><br></pre></td></tr></table></figure>
<p>注意：对于纯完全背包问题，遍历背包和遍历物品的顺序可以颠倒。但若将问题改为装满背包有几种方式，两种遍历方式就会有所不同。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description/">518. 零钱兑换 II</a></p>
<p>本题是完全背包求组合数，与<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/description/">494. 目标和</a>类似，区别在遍历背包时需要从前向后遍历！</p>
<ul>
<li>dp[i]：有dp[j]种方法可以凑成总金额j。</li>
<li>dp[i] += dp[i-coin[i]]</li>
<li>dp[0] = 1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp = [0] * (amount+1) # 有dp[j]种方法可以凑成总金额j</span><br><span class="line">dp[0] = 1</span><br><span class="line">for i in range(len(coins)):</span><br><span class="line">    for j in range(coins[i], amount+1):</span><br><span class="line">        dp[j] += dp[j - coins[i]]</span><br></pre></td></tr></table></figure>
<p><strong>求组合数是外层for循环遍历物品，内层for遍历背包。</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ</a></p>
<p>虽然题目叫组合总和，但其实求的是排列数。</p>
<p><strong>求排列数是外层for遍历背包，内层for循环遍历物品。</strong></p>
<p>注意为了防止<code>dp[j-num]</code>的下标溢出，需要加上判断条件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp = [0] * (target+1)</span><br><span class="line">dp[0] = 1</span><br><span class="line"># 因为是求排列，故先遍历背包，再遍历物品</span><br><span class="line">for j in range(1, target+1):</span><br><span class="line">    for num in nums:</span><br><span class="line">        if j &gt;= num: # 当背包容量大于等于物品重量</span><br><span class="line">            dp[j] += dp[j-num]</span><br></pre></td></tr></table></figure>
<p>类似的题目：</p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬至多m (1 &lt;= m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>该问题也可以视作一个完全背包求排列数的问题！</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换</a></p>
<ul>
<li>凑足总额为j所需的最小钱币数量为dp[j]。</li>
<li>初始化：因为求的是最小数量，故dp[0] = 0，其余均初始化为最大值</li>
<li>递推公式：dp[j] = min(dp[j-coin]+1, dp[j])</li>
</ul>
<p>如果给出的硬币不能凑齐总金额，则返回-1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if dp[amount] == float(&quot;inf&quot;):</span><br><span class="line">    return -1</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/description/">279. 完全平方数</a></p>
<p>与<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换</a>类似，都是求最小数量，不同点在于：</p>
<ul>
<li>没有具体硬币的值，需要将i从1遍历到<code>int(n**0.5)+1</code>。</li>
<li>不存在“凑不齐”这种情况，因为1是最小的完全平方数，n最多可以由n个1凑齐。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp = [float(&quot;inf&quot;)] * (n+1) # 和为j的完全平方数的最小数量为dp[j]</span><br><span class="line">dp[0] = 0</span><br><span class="line">for i in range(1, int(n ** 0.5) + 1):</span><br><span class="line">    for j in range(i*i, n+1):</span><br><span class="line">        dp[j] = min(dp[j - i*i] + 1, dp[j])</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/description/">139. 单词拆分</a></p>
<ul>
<li>对”ab”来说，可以由”a”+”b”凑成，但不能由”b”+”a”凑成，需要考虑顺序，故<strong>本题为求排列</strong>，需要先遍历背包。</li>
<li>dp[i]表示字符串的前i个字符是否可以被拆分成单词。</li>
<li>递推公式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if dp[i] and s[i:j] in wordSet:</span><br><span class="line">    dp[j] = True</span><br><span class="line">    break</span><br></pre></td></tr></table></figure></li>
<li>初始化：由递推公式可以看出，dp[0]一定为True，这是后续推导的基础；其余位置设置为False。</li>
<li>j从1开始遍历，因为dp[0]已经置True了，不需要从0开始。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wordSet = set(wordDict)</span><br><span class="line">n = len(s)</span><br><span class="line">dp = [False] * (n + 1) # dp[i]表示字符串的前i个字符是否可以被拆分成单词</span><br><span class="line">dp[0] = True</span><br><span class="line"></span><br><span class="line">for j in range(1, n + 1): # 排列问题，先遍历背包</span><br><span class="line">    for i in range(j): # 遍历单词</span><br><span class="line">        if dp[i] and s[i:j] in wordSet:</span><br><span class="line">            dp[j] = True</span><br><span class="line">            break</span><br></pre></td></tr></table></figure>
<h3 id="完全背包题型总结"><a href="#完全背包题型总结" class="headerlink" title="完全背包题型总结"></a>完全背包题型总结</h3><ul>
<li>求组合数：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description/">518. 零钱兑换 II</a>；</li>
<li>求排列数：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/description/">139. 单词拆分</a>；</li>
<li>求最小数：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/description/">322. 零钱兑换</a>、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/description/">279. 完全平方数</a>。</li>
</ul>
<h2 id="打家劫舍系列"><a href="#打家劫舍系列" class="headerlink" title="打家劫舍系列"></a>打家劫舍系列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/description/">198. 打家劫舍</a></p>
<ul>
<li>dp[i]表示考虑下标i以内的房屋，最多可以偷窃的金额为dp[i]。</li>
<li><code>dp[i] = max(dp[i-2]+nums[i], dp[i-1])</code></li>
<li>由递推公式可以看出，n=1和n=2的情况需要单独处理！</li>
<li>初始化：<code>dp[0]=nums[0], dp[1]=max(nums[0], nums[1])</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/description/">213. 打家劫舍 II</a></p>
<p>分为两种情况：</p>
<ol>
<li>不考虑首元素</li>
<li>不考虑尾元素</li>
</ol>
<p>故单独定义一个<code>robRange(nums, start, end)</code>函数，将<code>(nums, 0, len(nums)-2)</code>和<code>(nums, 1, len(nums)-1)</code>传进去，分别得到两种情况的最大值，再取max。</p>
<p>注意此时统一用dp数组书写不方便，故改用双指针的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pre_max = nums[start]</span><br><span class="line">cur_max = max(nums[start], nums[start+1])</span><br><span class="line">for i in range(start+2, end+1):</span><br><span class="line">    temp = cur_max</span><br><span class="line">    cur_max = max(cur_max, pre_max + nums[i])</span><br><span class="line">    pre_max = temp</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/description/">337. 打家劫舍 III</a></p>
<ul>
<li>dp[0]下标为0记录<strong>不偷该节点所能得到的最大金钱</strong>。</li>
<li>dp[1]下标为1记录<strong>偷该节点所能得到的最大金钱</strong>。</li>
<li>后序遍历，递归地从子节点向父节点递推，为得到(val1, val2)，递推公式：</li>
<li><code>val1 = max(left) + max(right)</code>：不偷当前节点，可偷子节点</li>
<li><code>val2 = node.val + left[0] + right[0]</code>：偷当前节点，不能偷子节点。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def traversal(self, node):</span><br><span class="line">    if not node:</span><br><span class="line">        return (0, 0)</span><br><span class="line"></span><br><span class="line">    left = self.traversal(node.left)</span><br><span class="line">    right = self.traversal(node.right)</span><br><span class="line"></span><br><span class="line">    # 不偷当前节点，可偷子节点</span><br><span class="line">    val1 = max(left[0], left[1]) + max(right[0], right[1])</span><br><span class="line">    # 偷当前节点，不能偷子节点</span><br><span class="line">    val2 = node.val + left[0] + right[0]</span><br><span class="line"></span><br><span class="line">    return (val1, val2)</span><br></pre></td></tr></table></figure>
<h2 id="股票系列"><a href="#股票系列" class="headerlink" title="股票系列"></a>股票系列</h2><p>股票问题的定义不需要在天数的基础上+1。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机</a></p>
<ul>
<li>dp[i][0]表示在第i天<strong>持有股票</strong>所得最多现金（“持有股票”，可能之前就持有，也可能第i天才买股票）</li>
<li>dp[i][1]表示在第i天<strong>不持有股票</strong>所得最多现金（“不持有股票”，可能之前就不持有，也可能第i天才卖股票）</li>
<li>初始化：<code>dp[0][0], dp[0][1] = -prices[0], 0</code>。</li>
<li>递推公式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], -prices[i])</span><br><span class="line">dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i])</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II</a></p>
<p>本题与<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">121. 买卖股票的最佳时机</a>类似，dp数组的定义，dp数组的初始化都一样。</p>
<p>不同之处在于，此时因为不限买入次数，所以第i天持有股票所得最多现金的来源有所改变，具体体现在递推公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])</span><br><span class="line">dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i])</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123. 买卖股票的最佳时机 III</a></p>
<p>本题可以分为4种状态，故dp数组可表示为：</p>
<ul>
<li>dp[i][0]表示第一次持有股票所得最多现金</li>
<li>dp[i][1]表示第一次不持有股票所得最多现金</li>
<li>dp[i][2]表示第二次持有股票所得最多现金</li>
<li>dp[i][3]表示第二次不持有股票所得最多现金</li>
</ul>
<p>相应的递推公式为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], -prices[i])</span><br><span class="line">dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i])</span><br><span class="line">dp[i][2] = max(dp[i-1][2], dp[i-1][1]-prices[i])</span><br><span class="line">dp[i][3] = max(dp[i-1][3], dp[i-1][2]+prices[i])</span><br></pre></td></tr></table></figure></p>
<p>注意初始化第一次持有股票最多现金时默认上一次不持有股票所得最多现金为0.</p>
<p>初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[0][0] = -prices[0]</span><br><span class="line">dp[0][2] = -prices[0]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188. 买卖股票的最佳时机 IV</a></p>
<p>本题思路与前几题类似。为了方便初始化第i天第一次持有股票所得最多现金，需要多加全为0的一列，对应不操作所得最多现金。</p>
<ul>
<li>dp[i][j]表示第i天的状态为j，所剩下的的最大现金为dp[i][j]</li>
<li>其中j=0表示不操作，j=1表示第一次持有，j=2表示第一次不持有，j=3表示第二次持有，j=4表示第二次不持有，以此类推。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp = [[0]*(2*k+1) for _ in range(len(prices))]</span><br><span class="line">for j in range(1, 2*k+1, 2):</span><br><span class="line">    dp[0][j] = -prices[0]</span><br></pre></td></tr></table></figure>
<p>递推公式（对持有股票和不持有股票）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1, len(prices)):</span><br><span class="line">    for j in range(1, 2*k+1, 2):</span><br><span class="line">        dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]-prices[i])</span><br><span class="line">        dp[i][j+1] = max(dp[i-1][j+1], dp[i-1][j]+prices[i])</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/">309. 买卖股票的最佳时机含冷冻期</a></p>
<p>状态分析（时间顺序）：|—持有股票—|—卖出股票—|—冷冻期—|—保持卖出股票—|</p>
<p>故dp数组可以定义为：</p>
<ul>
<li>dp[i][0]：持有股票状态</li>
<li>dp[i][1]：今天卖出股票</li>
<li>dp[i][2]：冷冻期</li>
<li>dp[i][3]：保持卖出股票状态</li>
</ul>
<p>初始化：<code>dp[0][0] = -prices[0]</code></p>
<p>递推公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] = max(dp[i-1][0], dp[i-1][2]-prices[i], dp[i-1][3]-prices[i])</span><br><span class="line">dp[i][1] = dp[i-1][0] + prices[i]</span><br><span class="line">dp[i][2] = dp[i-1][1]</span><br><span class="line">dp[i][3] = max(dp[i-1][3], dp[i-1][2], dp[i-1][1])</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/">714. 买卖股票的最佳时机含手续费</a></p>
<p>本题dp数组的定义初始化与<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">122. 买卖股票的最佳时机 II</a>相同，不同之处在于每笔交易需要付手续费，所以在递推公式中，在卖出股票时的最大现金减去手续费即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1, len(prices)):</span><br><span class="line">    dp[i][0] = max(dp[i-1][0], dp[i-1][1]-prices[i])</span><br><span class="line">    dp[i][1] = max(dp[i-1][1], dp[i-1][0]+prices[i]-fee)</span><br></pre></td></tr></table></figure>
<h2 id="子序列系列"><a href="#子序列系列" class="headerlink" title="子序列系列"></a>子序列系列</h2><h3 id="不连续子序列"><a href="#不连续子序列" class="headerlink" title="不连续子序列"></a>不连续子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列</a></p>
<p><strong>dp[i]表示i之前的包括i的以nums[i]为结尾的最长递增序列的长度。</strong></p>
<p>此处定义很重要，根据定义，需要返回max(dp)，不能返回dp[-1]。</p>
<p>初始化：递增子序列一定至少为1，将dp全初始化为1即可。</p>
<p>状态转移方程：对i和所有满足j &lt; i的j，当nums[i]&gt;nums[j]时进行状态转移：<code>dp[i] = max(dp[j]+1, dp[i])</code>即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def lengthOfLIS(self, nums: List[int]) -&gt; int:</span><br><span class="line">    # 动态规划</span><br><span class="line">    n = len(nums)</span><br><span class="line">    dp = [1] * n # dp[i]表示i之前的包括i的以nums[i]为结尾的最长递增序列的长度</span><br><span class="line">    for i in range(n):</span><br><span class="line">        for j in range(i):</span><br><span class="line">            if nums[j] &lt; nums[i]:</span><br><span class="line">                dp[i] = max(dp[j]+1, dp[i])</span><br><span class="line"></span><br><span class="line">    return max(dp)</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列</a></p>
<p>dp[i][j]表示长度为[0,i-1]的字符串text1与长度为[0,j-1]的字符串text2的最长公共子序列为dp[i][j]。</p>
<p>初始化：长度为[0,0]的字符串text1和text2的最长公共子序列长度为0，故全初始化为0即可。</p>
<p>注意：需要用到以上定义和初始化技巧的题目，dp的长度都要在原基础上+1！</p>
<p>状态转移方程：见代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int:</span><br><span class="line">    # 动态规划</span><br><span class="line">    m, n = len(text1), len(text2)</span><br><span class="line">    # 长度为[0,i-1]的字符串text1与长度为[0,j-1]的字符串text2</span><br><span class="line">    # 最长公共子序列为dp[i][j]</span><br><span class="line">    dp = [[0]*(n+1) for _ in range(m+1)]</span><br><span class="line">    for i in range(1, m+1):</span><br><span class="line">        for j in range(1, n+1):</span><br><span class="line">            if text1[i-1] == text2[j-1]:</span><br><span class="line">                dp[i][j] = dp[i-1][j-1] + 1</span><br><span class="line">            else:</span><br><span class="line">                dp[i][j] = max(dp[i][j-1], dp[i-1][j])</span><br><span class="line">    </span><br><span class="line">    return dp[-1][-1]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/description/">1035. 不相交的线</a></p>
<p>本题与<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列</a>完全一致。</p>
<h3 id="连续子序列"><a href="#连续子序列" class="headerlink" title="连续子序列"></a>连续子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/">674. 最长连续递增序列</a></p>
<p>本题与<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">300. 最长递增子序列</a>类似，但因为子序列连续，故递推更简单，只需要判断dp[i]和dp[i-1]的大小即可，不需要判断dp[i]和dp[j]的大小，j &lt; i。</p>
<p>dp[i]表示i之前的包括i的以nums[i]为结尾的最长递增序列的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1, n):</span><br><span class="line">    if nums[i] &gt; nums[i-1]:</span><br><span class="line">        dp[i] = dp[i-1] + 1</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/">718. 最长重复子数组</a></p>
<p>dp[i][j]表示以下标i-1为结尾的nums1和以下标j-1为结尾的nums2最长重复子数组的长度为dp[i][j]。</p>
<p>本题与<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列</a>类似，但因为子序列连续，故只能从一个方向递推得到dp[i][j]。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def findLength(self, nums1: List[int], nums2: List[int]) -&gt; int:</span><br><span class="line">    # 动态规划</span><br><span class="line">    m, n = len(nums1), len(nums2)</span><br><span class="line">    # dp[i][j]表示以下标i-1为结尾的nums1和以下标j-1为结尾的nums2</span><br><span class="line">    # 最长重复子数组的长度为dp[i][j]</span><br><span class="line">    dp = [[0] * (n + 1) for _ in range(m + 1)]</span><br><span class="line">    # 记录最长公共子数组的长度</span><br><span class="line">    result = 0</span><br><span class="line">    for i in range(1, m+1):</span><br><span class="line">        for j in range(1, n+1):</span><br><span class="line">            if nums1[i-1] == nums2[j-1]:</span><br><span class="line">                dp[i][j] = dp[i-1][j-1] + 1</span><br><span class="line">            result = max(result, dp[i][j])</span><br><span class="line"></span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">53. 最大子数组和</a></p>
<p>可用贪心算法，计算累积覆盖和，当覆盖和小于0时将覆盖和置零。</p>
<p>动态规划：dp[i]表示包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]。</p>
<p>递推公式：<code>dp[i] = max(dp[i-1] + nums[i], nums[i])</code>。</p>
<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/description/">392. 判断子序列</a></p>
<p>本题是编辑距离的第一步：删除元素。</p>
<p>dp[i][j]表示以i-1为结尾的字符串s，和以j-1为结尾的字符串t。</p>
<p>本题与<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列</a>类似，但是<strong>dp[i-1][j-1]可视作删除s[i]和t[j]</strong>，本题问s是否为t的子序列，只能删除t，不能删除s。</p>
<p>递推公式见代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def isSubsequence(self, s: str, t: str) -&gt; bool:</span><br><span class="line">    # 动态规划</span><br><span class="line">    m, n = len(s), len(t)</span><br><span class="line">    # dp[i][j]表示以i-1为结尾的字符串s，和以j-1为结尾的字符串t</span><br><span class="line">    # 相同子序列的长度为dp[i][j]</span><br><span class="line">    dp = [[0] * (n+1) for _ in range(m+1)]</span><br><span class="line">    for i in range(1, m+1):</span><br><span class="line">        for j in range(1, n+1):</span><br><span class="line">            if s[i-1] == t[j-1]:</span><br><span class="line">                dp[i][j] = dp[i-1][j-1] + 1</span><br><span class="line">            else:</span><br><span class="line">                dp[i][j] = dp[i][j-1]</span><br><span class="line">    if dp[-1][-1] == m:</span><br><span class="line">        return True</span><br><span class="line">    return False</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/description/">115. 不同的子序列</a></p>
<p>本题加深理解了编辑距离的删除操作。</p>
<p>dp[i][j]表示在s[:i-1]的子序列中t[:j-1]出现的个数</p>
<p>初始化：当j=0时，得到t的空子串，此时s可以有一种方法得到空串。从下面的递推公式也可以看出，后面的结果依赖前面的结果。</p>
<p>当s[i-1]==t[j-1]时，dp[i][j]可以由dp[i-1][j-1]推出来，也可以由dp[i-1][j]推出。前者是累计此前积累的数量，后者是考虑了比如s=”bagg”，t=”bag”的情况。</p>
<p>递推公式见代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def numDistinct(self, s: str, t: str) -&gt; int:</span><br><span class="line">    # 动态规划</span><br><span class="line">    m, n = len(s), len(t)</span><br><span class="line">    # dp[i][j]表示在s[:i-1]的子序列中t[:j-1]出现的个数</span><br><span class="line">    dp = [[0]*(n+1) for _ in range(m+1)]</span><br><span class="line">    # 初始化：当j=0时，得到t的空子串，此时s可以有一种方法得到空串</span><br><span class="line">    for i in range(m+1):</span><br><span class="line">        dp[i][0] = 1</span><br><span class="line">    </span><br><span class="line">    for i in range(1, m+1):</span><br><span class="line">        for j in range(1, n+1):</span><br><span class="line">            if s[i-1] == t[j-1]:</span><br><span class="line">                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]</span><br><span class="line">            else:</span><br><span class="line">                dp[i][j] = dp[i-1][j]</span><br><span class="line">    </span><br><span class="line">    return dp[-1][-1]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/">583. 两个字符串的删除操作</a></p>
<p>本题可以转化为求<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">1143. 最长公共子序列</a>，只需要将len(word1)和len(word2)加起来，减去2*最长公共子序列长度即可。</p>
<p>正向做法：</p>
<p>dp[i][j]表示以i-1结尾的word1，和以j-1结尾的word2想要达到相等，所需要删除元素的最小次数。</p>
<p>初始化：word2为空字符串，以i-1为结尾的字符串word1需要删除i个；同理，word1为空字符串，以j-1为结尾的字符串word2需要删除j个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def minDistance(self, word1: str, word2: str) -&gt; int:</span><br><span class="line">    # 动态规划</span><br><span class="line">    m, n = len(word1), len(word2)</span><br><span class="line">    # dp[i][j]表示以i-1结尾的word1，和以j-1结尾的word2</span><br><span class="line">    # 想要达到相等，所需要删除元素的最小次数</span><br><span class="line">    dp = [[0]*(n+1) for _ in range(m+1)]</span><br><span class="line">    # 初始化：word2为空字符串，以i-1为结尾的字符串word1需要删除i个</span><br><span class="line">    # 同理，word1为空字符串，以j-1为结尾的字符串word2需要删除j个</span><br><span class="line">    for i in range(m+1):</span><br><span class="line">        dp[i][0] = i</span><br><span class="line">    for j in range(n+1):</span><br><span class="line">        dp[0][j] = j</span><br><span class="line"></span><br><span class="line">    for i in range(1, m+1):</span><br><span class="line">        for j in range(1, n+1):</span><br><span class="line">            if word1[i-1] == word2[j-1]:</span><br><span class="line">                dp[i][j] = dp[i-1][j-1]</span><br><span class="line">            else:</span><br><span class="line">                dp[i][j] = min(dp[i][j-1]+1, dp[i-1][j]+1, dp[i-1][j-1]+2)</span><br><span class="line">    </span><br><span class="line">    return dp[-1][-1]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/description/">2. 编辑距离</a></p>
<p>dp[i][j]表示第i-1为结尾的word1和j-1为结尾的word2转换成相同的所使用的最小操作数。</p>
<p>删除操作与添加操作等价。</p>
<p>初始化：word2为空字符串，以i-1为结尾的字符串word1需要删除i个；同理，word1为空字符串，以j-1为结尾的字符串word2需要删除j个。</p>
<p>递归公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if word1[i-1] == word2[j-1]:</span><br><span class="line">    dp[i][j] = dp[i-1][j-1]</span><br><span class="line">else:</span><br><span class="line">    # 分别对应替换一个字符，删除word2中的字符，删除word1中的字符</span><br><span class="line">    dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1</span><br></pre></td></tr></table></figure>
<p>全代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def minDistance(self, word1: str, word2: str) -&gt; int:</span><br><span class="line">    # 动态规划</span><br><span class="line">    m, n = len(word1), len(word2)</span><br><span class="line">    # dp[i][j]表示第i-1为结尾的word1和j-1为结尾的word2</span><br><span class="line">    # 转换成相同的所使用的最小操作数</span><br><span class="line">    dp = [[0]*(n+1) for _ in range(m+1)]</span><br><span class="line">    # 初始化：当word1为空串时，以i-1为结尾的word2需要操作i次</span><br><span class="line">    # 同理，当word2为空串时，以j-1为结尾的word1需要操作j次</span><br><span class="line">    for i in range(m+1):</span><br><span class="line">        dp[i][0] = i</span><br><span class="line">    for j in range(n+1):</span><br><span class="line">        dp[0][j] = j</span><br><span class="line">    for i in range(1, m+1):</span><br><span class="line">        for j in range(1, n+1):</span><br><span class="line">            if word1[i-1] == word2[j-1]:</span><br><span class="line">                dp[i][j] = dp[i-1][j-1]</span><br><span class="line">            else:</span><br><span class="line">                dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1</span><br><span class="line">    return dp[-1][-1]</span><br></pre></td></tr></table></figure>
<h3 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/description/">647. 回文子串</a></p>
<p>dp不能定义为下标为i的字符串有dp[i]个回文串，否则dp[i],dp[i-1],dp[i+1]没有关系。</p>
<p>dp[i][j]定义为范围[i,j]（左闭右闭区间）的子串是否为回文子串，取值为bool值，初始化为False。</p>
<p>遍历顺序：从dp数组的<strong>下往上，左往右</strong>遍历。因为dp[i][j]是由dp[i+1][j-1]推出来的，而dp[i+1][j-1]在dp[i][j]的左下方！</p>
<p>递推公式见代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def countSubstrings(self, s: str) -&gt; int:</span><br><span class="line">    # 动态规划</span><br><span class="line">    # dp[i][j]表示区间范围[i,j]的子串是否是回文子串</span><br><span class="line">    dp = [[False]*len(s) for _ in range(len(s))]</span><br><span class="line">    result = 0</span><br><span class="line">    for i in range(len(s)-1, -1, -1):</span><br><span class="line">        for j in range(i, len(s)):</span><br><span class="line">            if s[i] == s[j]:</span><br><span class="line">                if j - i &lt;= 1:</span><br><span class="line">                    result += 1</span><br><span class="line">                    dp[i][j] = True</span><br><span class="line">                elif dp[i+1][j-1]:</span><br><span class="line">                    result += 1</span><br><span class="line">                    dp[i][j] = True</span><br><span class="line">    </span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/">516. 最长回文子序列</a></p>
<p>dp[i][j]表示dp[i][j]表示[i:j]最长的回文子序列的长度为dp[i][j]。</p>
<p>初始化：因为单个字符也是回文子序列，所以需要把dp[i][i]初始化为1。</p>
<p>遍历顺序依然是从dp的下到上，左到右遍历，因为dp[i][j]是由dp[i+1][j-1],dp[i][j-1],dp[i+1][j]推出来的。</p>
<p>注意内部循环，j从i+1开始取，为了防止dp[i+1][j-1]溢出！上题从i开始取，是因为<code>if j - i &lt;= 1</code>已经处理过该情况了。</p>
<p>递推公式见代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def longestPalindromeSubseq(self, s: str) -&gt; int:</span><br><span class="line">    # 动态规划</span><br><span class="line">    # dp[i][j]表示[i:j]最长的回文子序列的长度为dp[i][j]</span><br><span class="line">    dp = [[0]*len(s) for _ in range(len(s))]</span><br><span class="line">    # 初始化</span><br><span class="line">    for i in range(len(s)):</span><br><span class="line">        dp[i][i] = 1</span><br><span class="line">    </span><br><span class="line">    for i in range(len(s)-1, -1, -1):</span><br><span class="line">        for j in range(i+1, len(s)):</span><br><span class="line">            if s[i] == s[j]:</span><br><span class="line">                dp[i][j] = dp[i+1][j-1] + 2</span><br><span class="line">            else:</span><br><span class="line">                dp[i][j] = max(dp[i][j-1], dp[i+1][j])</span><br><span class="line">    </span><br><span class="line">    return dp[0][-1]</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="linpandas 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="linpandas 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/03/30/Leetcode%E6%80%BB%E7%BB%93-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AF%87/" rel="prev" title="LeetCode总结——贪心算法篇">
                  <i class="fa fa-chevron-left"></i> LeetCode总结——贪心算法篇
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/04/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%AF%87/" rel="next" title="排序算法篇">
                  排序算法篇 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">linpandas</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
